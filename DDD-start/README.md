# DDD Start

# Chapter 1 도메인 모델의 시작
## 도메인 모델
- 도메인 자체를 표현하는 개념적인 모델을 의미하지만, 도메인 계층을 구현할 때 사용하는 객체 모델을 언급할 때에도 '도메인 모델'  이란 용어를 사용한다.  
도메인 계층의 객체 모델을 표현할 때 도메인 모델이라고 표현하고 있다.

### 개념 모델과 구현모델
- 처음부터 완벽한 개념 모델을 만들기보다는 전반적인 개요를 알 수 있는 수준으로 개념 모델을 작성해야한다.
- 프로젝트 초기에는 개요 수준의 개념모델로 도메인에 대한 전체 윤곽을 이해하는데 집중하고, 구현하는 과정에서 개념 모델을 구현모델로 점진적으로 발전시켜 나가야 한다.

## 도메인 모델 패턴
사용자인터페이스(UI) : 사용자의 요청을 처리하고 사용자에게 정보를 보여준다.  
응용 (Application) : 사용자가 요청한 기능을 실행한다.  
도메인 : 시스템이 제공할 도메인의 규칙을 구현한다.  
인프라스트럭처(Infrastructure) : 데이터베이스나 메시징 시스템과 같은 외부 시스팀과의 연동을 처리한다.  

## 도메인 모델 도출
- 구현을 시작하려면 도메인에 대한 초기 모델이 필요하다.
- 도메인을 모델링할 때 기본이 되는 작업은 모델을 구성하는 **핵심 구성요소**, **규칙**, **기능**을 찾는것이다.
- 이 과정은 요구사항에서 출발한다.

### 문서화
- 문서화를 하는 주된 이유는 지식을 공유하기 위함이다.
- 전반적인 기능 목록이나 모듈 구조, 빌드 과정은 코드를 보고 직접 이해하는 것보다 상위 수준에서 정리한 문서를 참조하는 것이 소프트웨어  
전반을 빠르게 이해하는데 도움이 된다.

## 엔티티와 밸류
- 도출한 모델은 크게 엔티티(Entity)와 밸류(Value)로 구분할 수 있다. 

### 엔티티
- 가장 큰 특징은 식별자를 갖는다
- 각 엔티티는 서로 다른 식별자를 갖는다.

### 밸류 타입 
- 개념적으로 완전한 하나를 표현할 때 사용한다.
- 코드의 의미를 더 잘 이해할 수 있도록 한다.
- 밸류 객체의 데이터를 변경할 때는 기존 데이터를 변경하기 보다는 변경한 데이터를 갖는 새로운 밸류 객체를 생성하는 방식을 선호한다.
- 밸류 타입을 **불변**으로 구현하는 가장 중요한 이유는 안전한 코드를 작성할 수 있다는 것이다.
- 밸류 타입이 같은지를 비교할때는 모든 속성이 같은지 비교해야 한다.

### 엔티티 식별자와 밸류타입
- Money가 단순 숫자가 아닌 도메인의 '돈'을 의미하는 것처럼 이런 식별자는 단순한  
문자열이 아니라 도메인엣 ㅓ특별한 의미를 지니는 경우가 많기 떄문에 식별자를 위한 밸류타입을 사용해서 의미가 잘 드러나도록 할 수 있다.

### 도메인 모델에 set 메서드 넣지 않기
- 도메인 모델에 get/set 메서드를 무조건 추가하는 것은 좋지 않은 버릇이다.
- set 메서드는 도메인의 핵심 개념이나 의도를 코드에서 사라지게 한다.
- 도메인 객체가 불완전한 상태로 사용되는 것을 막으려면 생성시점에 필요한 것을 전달해 주어야한다.
- 즉, 생성자를 통해 필요한 데이터를 모두 받아야한다.

## 도메인 용어
- 도메인 용어는 좋은 코드를 만드는 데 매우 증요한 요소다
- 알맞은 영어 단어를 찾는 것은 쉽지 않은 일이지만 시간을 들여 찾는 노력을 해야한다.

# Chapter 2 아키텍처 개요
## 네 개의 영역
![4개의 영역](./images/chapter02/layer.png)
## 계층 구조 아키텍처
- 계층 구조에 따르면 표현, 응용, 도메인 계층이 상세한 구현 기술을 다루는 인프라스터럭처 계층에 종속된다
- 인프라스트럭처에 의존하면 '테스트 어려움'과 '기능 확장의 어려움'이라는 두가지 문제가 발생한다
- 이 두묹제를 해결하려면 DIP를 적용해야한다

## DIP (Dependency Injection Principle)
- 고수준 모듈이 제대로 동작하려면 저수준 모듈을 사용해야한다.  
그런데, 고수준 모듈이 저수준 모듈을 사용하면 앞서 계층 구조 아키텍처에서 언급했던 두가지('테스트 어려움'과 '기능 확장의 어려움')
문제가 발생한다
- DIP는 저수준 모듈이 고수준 모듈에 의존하도록 바꾼다. -> **비밀은 추상화한 인터페이스에 있다.**

### DIP 주의사항
- DIP의 핵심은 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함이다.
- DIP를 적용할 떄 하위 기능을 추상화한 인터페이스는 고수준 모듈 관점에서 도출한다.

### DIP와 아키텍처

## 도메인 영역의 주요 구성요소
1. 엔티티
2. 밸류
3. 애그리거트
4. 리포지터리
5. 도메인 서비스 : 특정 엔티티에 속하지 않는 도메인 로직을 제공한다. 도메인 로직이 여러 엔티티와 밸류를 필요로 할 경우 도메인 서비스에서 로직을 구현한다.

### 애그리거트
- 도메인 모델도 개별 객체뿐만 아니라 상위 수준에서 모델을 볼 수 있어야 전체 모델의 관계와 개별 모델을 이해하는데 도움이 된다.
- 도메인 모델에서 전체 구조를 이해하는데 도움이 되는것이 에그리거트이다.
- 애그리거트는 관련 객체를 하나로 묶은 군집이다.
![애그리거트](./images/chapter02/aggregate.png)

### 리포지터리
- 도메인 객체를 지속적으로 사용하려면 RDBMS, NoSQL, 로컬 파일과 같은 물리적인 저장소에 도메인 객체를 보관해야한다.
- 이를 위한 도메인 모델이 리포지터리이다.
- 리포지터리의 사용 주체가 응용 서비스이기 떄문에 리포지터리는 응용서비스가 필요로하는 메서드를 제공한다.

## 요청 처리 흐름
![요청 처리 흐름](./images/chapter02/call_flow.png)

## 인프라스터럭처 개요
- 표현 영역, 응용 영역, 도메인 영역을 지원한다.
- 무조건 인프라스트럭처에 대한 의존을 없애는 것이 좋은 것은 아니다.
- 예로 @Transaction 애노테이션이있다 (자세한 이유는 P67)

## 모듈 구성
- 각 애그리거트와 모델과 리포지터리는 같은 패키지에 위치시킨다.
- 예를 들어, 주문과 관련된 Order, OrderLine, Orderer, OrderRepository 등은 com.myshop.order.domain 패키지에 위치시킨다.
- 한 패키지에 너무 많은 타입이 몰려서 코드를 찾을 때 불편한 정도만 아니면 된다.
- 저자는 한패키지에 가능하면 10개 미만으로 타입 개수를 유지하려고 노력한다고한다
- 이 개수가 넘어가면 모듈을 분리하는 시도를 해본다.

# Chapter 3 애그리거트

## 애그리거트 
- 애그리거트는 모델을 이해하는데 도움을 줄 뿐만 아니라 일관성을 관리하는 기준이 된다.
- 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.

## 애그리거트 루트
- 애그리거트에 속한 모둔 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데 이 책임을지는것이 바로
애그리거트의 루트 앤티티이다.

### 도메인 규칙과 일관성
- 불필요한 중복을 피하고 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 아래의 두가지를 적용해야한다
  - 단순히 필드를 변경하는 set 메서드르 공개(public) 범위로 만들지 않는다.
  - 밸류 타입은 불변으로 구현한다.
- 공개 set 메서드를 만들지 않는것의 연장으로 밸류는 불변타입으로 구혀한다.
```java
ShippoingInfo si = order.getShippingInfo();
si.setAddress(newAddress); //ShippingInfo 밸류 객체가 불변이면, 이 코드는 컴파일 에러!
```

### 애그리거트 루트의 기능 구현
- 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다.
- 애그리거트 루트가 구성요소의 상태만 참조하는 것은 아니다. 기능 실행을 위임하기도 한다.(예제코드 P81)
- 팀 표준이나 구현 기술의 제약으로 OrderLines(밸류 타입)를 불변으로 구현할 수 없다면 OrderLines의 변경 기능을 패키지나
protected 범위로 한정해서 외부에서 실행할 수 없도록 제한하는 방법이 있다.

### 트랜잭션 범위
- 트랜잭션 범위는 작을 수록 좋다.
  - 잠금 대상이 많아진다는 것은 그만큼 동시에 처리할 수 있는 트랜잭션 개수가 줄어든다는 것을 뜻하고 이는 전체적인 성능(처리량)을
  떨어 뜨린다.
- **한 트랜잭션에서는 한 개의 애그리거트만 수정해야한다.**
- 한 애그리거트에서 다른 애그리거트를 수정하면 결과적으로 두개의 애그리거트를 한 트랜잭션에서 수정하게 되므로 한 애그리거트 내부에서  
다른 애그리거트의 상태를 변경하는 기능을 실행하면 안 된다.
- (에제 코드 83)
- 해결방법 두가지
  - 응용서비스에서 두 애그리거트를 수정하도록 구현한다.
  - 도메인 이벤트를 사용한다.
- 한 트랜잭션에서 한개의 애그리거트를 변경하는 것을 권장하지만 다음의 경우에는 한개의 트랜잭션에서
두개 이상의 애그리거트를 변경하는 것을 고려할 수 있다.
  - 팀표준
  - 기술 제약
  - UI 구현의 편리

## 리포지터리와 애그리거트
- 애그리거트는 개념상 완전한 한 개의 도메인 모델을 표한하므로 객체의 영속성을 처리하는 **리포지터리는 애그리거트 단위로 존재**한다.
- 애그리거트는 개념적을 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속해야한다.
- 애그리거트를 영속화할 저장소로 무엇을 사용하든지 간에 **애드리거트의 상태가 변경되면 모든 변경을 원자적을 저장소에 반영**해야한다.
  - 애그리거트에서 두 개의 객체를 변경했는데 저장소에는 한 객체에 대한 변경만 반영되면 데이터 **일관성**이 깨지므로 문제가 된다.



